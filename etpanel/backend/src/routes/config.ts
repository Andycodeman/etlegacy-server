import { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { db, schema } from '../db/index.js';
import { eq, desc } from 'drizzle-orm';
import { sendRcon } from '../services/rcon.js';
import { authenticate, requireAdmin } from '../middleware/auth.js';
import { readdir, readFile, writeFile, unlink } from 'fs/promises';
import { join } from 'path';
import { existsSync } from 'fs';

const cvarUpdateSchema = z.object({
  cvars: z.record(z.string(), z.string()),
});

const templateSchema = z.object({
  name: z.string().min(1).max(100),
  cvars: z.record(z.string(), z.string()),
});

const saveAsMapConfigSchema = z.object({
  mapName: z.string().min(1).max(100),
});

// Strip ET color codes (^0-^9, ^a-^z, etc.)
function stripColors(text: string): string {
  return text.replace(/\^[0-9a-zA-Z]/g, '');
}

// CVARs that are safe to modify via API
const ALLOWED_CVARS = new Set([
  'g_gravity',
  'g_speed',
  'g_knockback',
  'g_warmup',
  'timelimit',
  'g_soldierAllWeapons',
  'g_panzerFireRate',
  'g_grenadeFireRate',
  'g_mg42FireRate',
  'g_pistolFireRate',
  'g_mg42Overheat',
  'g_ammoUnlimited',
  'g_panzerfestEnabled',
  'g_panzerfestKills',
  'g_panzerfestMultiplier',
  'g_survivalEnabled',
  'g_survivalInterval',
  'g_survivalMaxBonus',
  'g_killStreakEnabled',
  'g_killStreakKills',
  'g_killStreakMaxBonus',
  'bot_minplayers',
]);

// Path to ET:Legacy mapconfigs directory on VPS
const MAPCONFIGS_DIR = process.env.MAPCONFIGS_DIR || '/home/andy/etlegacy/legacy/mapconfigs';

// Parse a .cfg file into a Record of cvars
function parseCfgFile(content: string): Record<string, string> {
  const cvars: Record<string, string> = {};
  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();
    // Skip comments and empty lines
    if (!trimmed || trimmed.startsWith('//')) continue;

    // Match: set cvar "value" or set cvar value or just cvar "value"
    const setMatch = trimmed.match(/^set\s+(\w+)\s+"?([^"]*)"?$/i);
    if (setMatch) {
      cvars[setMatch[1]] = setMatch[2];
      continue;
    }

    // Match: cvar "value" or cvar value (without set)
    const directMatch = trimmed.match(/^(\w+)\s+"?([^"]*)"?$/);
    if (directMatch && ALLOWED_CVARS.has(directMatch[1])) {
      cvars[directMatch[1]] = directMatch[2];
    }
  }

  return cvars;
}

// Convert cvars to .cfg file content
function toCfgContent(cvars: Record<string, string>): string {
  const lines = [
    '// Map configuration file',
    '// Generated by ETPanel',
    '',
  ];

  for (const [cvar, value] of Object.entries(cvars)) {
    if (ALLOWED_CVARS.has(cvar) && value !== '') {
      lines.push(`set ${cvar} "${value}"`);
    }
  }

  return lines.join('\n') + '\n';
}

export const configRoutes: FastifyPluginAsync = async (fastify) => {
  // ============ LIVE SERVER CVARS ============

  // Get current CVARs from running server
  fastify.get('/cvars', { preHandler: authenticate }, async () => {
    const results: Record<string, string> = {};

    for (const cvar of ALLOWED_CVARS) {
      const result = await sendRcon(cvar);
      if (result.success) {
        const match = result.response.match(/"([^"]+)" is:\s*"([^"]*)"/);
        if (match) {
          results[match[1]] = stripColors(match[2]);
        }
      }
    }

    return { cvars: results, allowed: Array.from(ALLOWED_CVARS) };
  });

  // Update CVARs on running server (admin only)
  fastify.post('/cvars', { preHandler: requireAdmin }, async (request, reply) => {
    const body = cvarUpdateSchema.safeParse(request.body);
    if (!body.success) {
      return reply.status(400).send({ error: 'Invalid input' });
    }

    const results: Record<string, { success: boolean; message: string }> = {};

    for (const [cvar, value] of Object.entries(body.data.cvars)) {
      if (!ALLOWED_CVARS.has(cvar)) {
        results[cvar] = { success: false, message: 'CVAR not allowed' };
        continue;
      }

      const result = await sendRcon(`set ${cvar} "${value}"`);
      results[cvar] = {
        success: result.success,
        message: result.success ? 'Updated' : result.error || 'Failed',
      };
    }

    fastify.log.info({ user: request.user.email, cvars: body.data.cvars }, 'CVARs updated');

    return { results };
  });

  // ============ CONFIG TEMPLATES (Database) ============

  // List all templates
  fastify.get('/templates', { preHandler: authenticate }, async () => {
    const templates = await db
      .select({
        id: schema.configSnapshots.id,
        name: schema.configSnapshots.name,
        createdAt: schema.configSnapshots.createdAt,
        createdBy: schema.users.displayName,
      })
      .from(schema.configSnapshots)
      .leftJoin(schema.users, eq(schema.configSnapshots.createdBy, schema.users.id))
      .orderBy(schema.configSnapshots.name);

    return templates;
  });

  // Get template by ID
  fastify.get('/templates/:id', { preHandler: authenticate }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const templateId = parseInt(id);

    if (isNaN(templateId)) {
      return reply.status(400).send({ error: 'Invalid template ID' });
    }

    const [template] = await db
      .select()
      .from(schema.configSnapshots)
      .where(eq(schema.configSnapshots.id, templateId))
      .limit(1);

    if (!template) {
      return reply.status(404).send({ error: 'Template not found' });
    }

    return template;
  });

  // Create new template (admin only)
  fastify.post('/templates', { preHandler: requireAdmin }, async (request, reply) => {
    const body = templateSchema.safeParse(request.body);
    if (!body.success) {
      return reply.status(400).send({ error: 'Invalid input' });
    }

    // Filter to only allowed CVARs
    const filteredCvars: Record<string, string> = {};
    for (const [cvar, value] of Object.entries(body.data.cvars)) {
      if (ALLOWED_CVARS.has(cvar)) {
        filteredCvars[cvar] = value;
      }
    }

    const [template] = await db
      .insert(schema.configSnapshots)
      .values({
        name: body.data.name,
        configJson: filteredCvars,
        createdBy: request.user.userId,
      })
      .returning();

    fastify.log.info({ user: request.user.email, templateId: template.id, name: template.name }, 'Config template created');

    return template;
  });

  // Apply template to running server (admin only)
  fastify.post('/templates/:id/apply', { preHandler: requireAdmin }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const templateId = parseInt(id);

    if (isNaN(templateId)) {
      return reply.status(400).send({ error: 'Invalid template ID' });
    }

    const [template] = await db
      .select()
      .from(schema.configSnapshots)
      .where(eq(schema.configSnapshots.id, templateId))
      .limit(1);

    if (!template) {
      return reply.status(404).send({ error: 'Template not found' });
    }

    const cvars = template.configJson as Record<string, string>;
    const results: Record<string, { success: boolean; message: string }> = {};

    for (const [cvar, value] of Object.entries(cvars)) {
      if (!ALLOWED_CVARS.has(cvar)) {
        results[cvar] = { success: false, message: 'CVAR not allowed' };
        continue;
      }

      const result = await sendRcon(`set ${cvar} "${value}"`);
      results[cvar] = {
        success: result.success,
        message: result.success ? 'Applied' : result.error || 'Failed',
      };
    }

    fastify.log.info(
      { user: request.user.email, templateId, templateName: template.name },
      'Config template applied to server'
    );

    return { results };
  });

  // Save template as map config file (admin only)
  fastify.post('/templates/:id/save-as-mapconfig', { preHandler: requireAdmin }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const templateId = parseInt(id);
    const body = saveAsMapConfigSchema.safeParse(request.body);

    if (isNaN(templateId)) {
      return reply.status(400).send({ error: 'Invalid template ID' });
    }

    if (!body.success) {
      return reply.status(400).send({ error: 'Invalid map name' });
    }

    const [template] = await db
      .select()
      .from(schema.configSnapshots)
      .where(eq(schema.configSnapshots.id, templateId))
      .limit(1);

    if (!template) {
      return reply.status(404).send({ error: 'Template not found' });
    }

    const cvars = template.configJson as Record<string, string>;
    const cfgContent = toCfgContent(cvars);
    const filePath = join(MAPCONFIGS_DIR, `${body.data.mapName}.cfg`);

    try {
      await writeFile(filePath, cfgContent, 'utf-8');
      fastify.log.info(
        { user: request.user.email, templateId, mapName: body.data.mapName },
        'Template saved as map config file'
      );
      return { success: true, mapName: body.data.mapName, path: filePath };
    } catch (error) {
      fastify.log.error({ error, filePath }, 'Failed to write map config file');
      return reply.status(500).send({ error: 'Failed to write map config file' });
    }
  });

  // Delete template (admin only)
  fastify.delete('/templates/:id', { preHandler: requireAdmin }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const templateId = parseInt(id);

    if (isNaN(templateId)) {
      return reply.status(400).send({ error: 'Invalid template ID' });
    }

    await db.delete(schema.configSnapshots).where(eq(schema.configSnapshots.id, templateId));

    return { success: true };
  });

  // ============ MAP CONFIG FILES (Disk) ============

  // List all map config files
  fastify.get('/mapfiles', { preHandler: authenticate }, async (request, reply) => {
    try {
      if (!existsSync(MAPCONFIGS_DIR)) {
        return [];
      }

      const files = await readdir(MAPCONFIGS_DIR);
      const cfgFiles = files
        .filter(f => f.endsWith('.cfg'))
        .map(f => f.replace('.cfg', ''))
        .sort();

      return cfgFiles;
    } catch (error) {
      fastify.log.error({ error, dir: MAPCONFIGS_DIR }, 'Failed to read mapconfigs directory');
      return reply.status(500).send({ error: 'Failed to read map configs directory' });
    }
  });

  // Get map config file content
  fastify.get('/mapfiles/:mapName', { preHandler: authenticate }, async (request, reply) => {
    const { mapName } = request.params as { mapName: string };
    const filePath = join(MAPCONFIGS_DIR, `${mapName}.cfg`);

    try {
      if (!existsSync(filePath)) {
        return reply.status(404).send({ error: 'Map config file not found', mapName });
      }

      const content = await readFile(filePath, 'utf-8');
      const cvars = parseCfgFile(content);

      return { mapName, cvars, raw: content };
    } catch (error) {
      fastify.log.error({ error, filePath }, 'Failed to read map config file');
      return reply.status(500).send({ error: 'Failed to read map config file' });
    }
  });

  // Create or update map config file (admin only)
  fastify.put('/mapfiles/:mapName', { preHandler: requireAdmin }, async (request, reply) => {
    const { mapName } = request.params as { mapName: string };
    const body = cvarUpdateSchema.safeParse(request.body);

    if (!body.success) {
      return reply.status(400).send({ error: 'Invalid input' });
    }

    const cfgContent = toCfgContent(body.data.cvars);
    const filePath = join(MAPCONFIGS_DIR, `${mapName}.cfg`);

    try {
      await writeFile(filePath, cfgContent, 'utf-8');
      fastify.log.info({ user: request.user.email, mapName }, 'Map config file saved');
      return { success: true, mapName };
    } catch (error) {
      fastify.log.error({ error, filePath }, 'Failed to write map config file');
      return reply.status(500).send({ error: 'Failed to write map config file' });
    }
  });

  // Delete map config file (admin only)
  fastify.delete('/mapfiles/:mapName', { preHandler: requireAdmin }, async (request, reply) => {
    const { mapName } = request.params as { mapName: string };
    const filePath = join(MAPCONFIGS_DIR, `${mapName}.cfg`);

    try {
      if (!existsSync(filePath)) {
        return reply.status(404).send({ error: 'Map config file not found' });
      }

      await unlink(filePath);
      fastify.log.info({ user: request.user.email, mapName }, 'Map config file deleted');
      return { success: true };
    } catch (error) {
      fastify.log.error({ error, filePath }, 'Failed to delete map config file');
      return reply.status(500).send({ error: 'Failed to delete map config file' });
    }
  });

  // ============ LEGACY ROUTES (for backwards compatibility) ============

  // Keep /snapshots routes pointing to templates for now
  fastify.get('/snapshots', { preHandler: authenticate }, async () => {
    const templates = await db
      .select({
        id: schema.configSnapshots.id,
        name: schema.configSnapshots.name,
        createdAt: schema.configSnapshots.createdAt,
        createdBy: schema.users.displayName,
      })
      .from(schema.configSnapshots)
      .leftJoin(schema.users, eq(schema.configSnapshots.createdBy, schema.users.id))
      .orderBy(desc(schema.configSnapshots.createdAt));

    return templates;
  });

  fastify.post('/snapshots/:id/apply', { preHandler: requireAdmin }, async (request, reply) => {
    const { id } = request.params as { id: string };
    const templateId = parseInt(id);

    if (isNaN(templateId)) {
      return reply.status(400).send({ error: 'Invalid snapshot ID' });
    }

    const [template] = await db
      .select()
      .from(schema.configSnapshots)
      .where(eq(schema.configSnapshots.id, templateId))
      .limit(1);

    if (!template) {
      return reply.status(404).send({ error: 'Snapshot not found' });
    }

    const cvars = template.configJson as Record<string, string>;
    const results: Record<string, { success: boolean; message: string }> = {};

    for (const [cvar, value] of Object.entries(cvars)) {
      if (!ALLOWED_CVARS.has(cvar)) {
        results[cvar] = { success: false, message: 'CVAR not allowed' };
        continue;
      }

      const result = await sendRcon(`set ${cvar} "${value}"`);
      results[cvar] = {
        success: result.success,
        message: result.success ? 'Applied' : result.error || 'Failed',
      };
    }

    fastify.log.info(
      { user: request.user.email, snapshotId: templateId, snapshotName: template.name },
      'Config snapshot applied'
    );

    return { results };
  });
};
